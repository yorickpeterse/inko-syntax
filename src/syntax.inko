# A simple syntax highlighting library for Inko.
import std.cmp.Equal
import std.fmt.(Format, Formatter)
import std.iter.Iter
import std.string.Bytes
import syntax.helpers.(LF, whitespace?)

# The value returned by `Lexer.current` and `Lexer.peek` to signal the end of
# the input is reached.
let pub EOF = -1

# A token to highlight.
#
# A token can be a comment, a string, a keyword, or just regular text.
class pub enum Token {
  # A single or multi-line comment.
  case Comment(String)

  # A double quoted string.
  case DoubleString(String)

  # A single quoted string.
  case SingleString(String)

  # An integer.
  case Int(String)

  # A float (e.g. `10.5` or `10e5`).
  case Float(String)

  # Regular text, such as unrecognized/highlighted words or whitespace.
  case Text(String)

  # A keyword, such as `class`.
  case Keyword(String)

  # A reference to a field, such as `self.foo` in Rust or `@foo` in Inko.
  case Field(String)
}

impl Equal[Token] for Token {
  fn pub ==(other: ref Token) -> Bool {
    match (self, other) {
      case (Comment(a), Comment(b)) -> a == b
      case (DoubleString(a), DoubleString(b)) -> a == b
      case (SingleString(a), SingleString(b)) -> a == b
      case (Int(a), Int(b)) -> a == b
      case (Float(a), Float(b)) -> a == b
      case (Text(a), Text(b)) -> a == b
      case (Keyword(a), Keyword(b)) -> a == b
      case (Field(a), Field(b)) -> a == b
      case _ -> false
    }
  }
}

impl Format for Token {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Comment(v) -> formatter.tuple('Comment').field(v).finish
      case DoubleString(v) -> formatter.tuple('DoubleString').field(v).finish
      case SingleString(v) -> formatter.tuple('SingleString').field(v).finish
      case Int(v) -> formatter.tuple('Int').field(v).finish
      case Float(v) -> formatter.tuple('Float').field(v).finish
      case Text(v) -> formatter.tuple('Text').field(v).finish
      case Keyword(v) -> formatter.tuple('Keyword').field(v).finish
      case Field(v) -> formatter.tuple('Field').field(v).finish
    }
  }
}

# A type that represents a bunch of bytes to process using a lexer.
class Buffer {
  let @bytes: ref Bytes
  let @offset: Int

  fn static new(bytes: ref Bytes) -> Buffer {
    Buffer { @bytes = bytes, @offset = 0 }
  }

  fn size -> Int {
    @bytes.size
  }

  fn get -> Int {
    peek(0)
  }

  fn peek(amount: Int) -> Int {
    let idx = @offset + amount

    if idx < @bytes.size { @bytes.byte(idx) } else { EOF }
  }

  fn slice(start: Int, stop: Int) -> String {
    @bytes.slice(start, stop - start).into_string
  }

  fn mut advance_until_eol {
    while get != EOF and get != LF { @offset += 1 }
  }

  fn mut advance_whitespace {
    while whitespace?(get) { @offset += 1 }
  }
}
