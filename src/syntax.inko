import std.fmt.(Format, Formatter)
import std.iter.Iter
import std.string.Bytes

let PLUS = 43
let HYPHEN = 45
let PERIOD = 46
let ZERO = 48
let NINE = 57
let UPPER_E = 69
let UNDER = 95
let LOWER_E = 101

# Returns `true` if the given byte is a digit in the inclusive range of 0 to 9.
fn pub digit?(byte: Int) -> Bool {
  byte >= ZERO and byte <= NINE
}

# A token to highlight.
#
# A token can be a comment, a string, a keyword, or just regular text.
class pub enum Token {
  # A single or multi-line comment.
  case Comment(String)

  # A double quoted string.
  case DoubleString(String)

  # A single quoted string.
  case SingleString(String)

  # An integer.
  case Int(String)

  # A float (e.g. `10.5` or `10e5`).
  case Float(String)

  # Regular text, such as unrecognized/highlighted words or whitespace.
  case Text(String)

  # A keyword, such as `class`.
  case Keyword(String)

  # A symbol, such as `[` or `^`.
  case Symbol(String)

  # Code that isn't syntactically correct.
  case Error(String)
}

impl Format for Token {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Comment(v) -> formatter.tuple('Comment').field(v).finish
      case DoubleString(v) -> formatter.tuple('DoubleString').field(v).finish
      case SingleString(v) -> formatter.tuple('SingleString').field(v).finish
      case Int(v) -> formatter.tuple('Int').field(v).finish
      case Float(v) -> formatter.tuple('Float').field(v).finish
      case Text(v) -> formatter.tuple('Text').field(v).finish
      case Keyword(v) -> formatter.tuple('Keyword').field(v).finish
      case Symbol(v) -> formatter.tuple('Symbol').field(v).finish
      case Error(v) -> formatter.tuple('Error').field(v).finish
    }
  }
}

# A type that turns source code into a stream of `Token` values.
trait pub Lexer: Iter[Token] {
  # Returns the bytes to lex.
  fn pub bytes -> ref Bytes

  # Returns the current byte offset.
  fn pub offset -> Int

  # Advances the cursor to the next byte.
  fn pub mut advance

  # Returns the byte at the current byte offset.
  #
  # If all bytes are consumed, this method returns `-1`
  fn pub current -> Int {
    if offset < bytes.size { bytes.byte(offset) } else { -1 }
  }

  # Returns the byte at the next byte offset.
  #
  # If all bytes are consumed, this method returns `-1`
  fn pub peek -> Int {
    let idx = offset + 1

    if idx < bytes.size { bytes.byte(idx) } else { -1 }
  }

  # Slices the range of bytes into a `String`.
  fn pub slice(start: Int, stop: Int) -> String {
    bytes.slice(start, stop - start).into_string
  }
}

# Methods for lexing numbers.
trait pub Numbers: Lexer {
  # Lexes a sequence into either an integer or a float.
  #
  # This method supports the following formats:
  #
  # - `10`
  # - `10_00`
  # - `10.2`
  # - `10e2`
  # - `10E2`
  # - `10e+2`
  # - `10e-2`
  # - `10e2`
  #
  # This method expects that `current` points to a valid digit (as decided by
  # the `digit?` method) at the start.
  fn pub mut number -> Token {
    let start = offset

    digits

    match current {
      case PERIOD -> {
        if digit?(peek).false? { return Token.Int(slice(start, offset - 1)) }

        advance
        digits
        Token.Float(slice(start, offset))
      }
      case LOWER_E or UPPER_E -> {
        advance

        match current {
          case PLUS or HYPHEN -> advance
          case byte if digit?(byte) -> advance
          case _ -> return Token.Error(slice(start, offset))
        }

        digits
        Token.Float(slice(start, offset))
      }
      case _ -> Token.Int(slice(start, offset))
    }
  }

  # Advances the cursor as long as the current byte is a digit or an underscore.
  fn pub mut digits {
    while digit?(current) or current == UNDER { advance }
  }
}
